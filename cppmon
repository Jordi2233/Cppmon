#!/usr/bin/env python3

import os
import sys
import time
import subprocess
import argparse
import multiprocessing
from termcolor import colored


def cppmon(files, stop_event):
    """
    This function monitors the specified files for changes and automatically compiles and runs the C++ code
    if a change is detected.
    """

    # Initialize the dictionary of file timestamps and sizes
    try:
        check_files_exist(files)
        changes = {f: (os.path.getmtime(f), os.path.getsize(f)) for f in files}
    except FileNotFoundError:
        sys.exit(1)

    while not stop_event.is_set():
        try:
            check_files_exist(files)
            time.sleep(0.1)

            for file in files:
                mod_time, size = os.path.getmtime(file), os.path.getsize(file)
                if (mod_time, size) != changes[file]:
                    print(
                        colored(f"\n<== {file} ==>\nHas been modified. Recompiling...", "cyan"))

                    short_file = os.path.splitext(file)[0]
                    res = subprocess.run(
                        ["g++", "-o", short_file, file], stderr=subprocess.PIPE)
                    if res.returncode == 0:
                        print(
                            colored("Compilation successful. Running program:", "green"))
                        subprocess.run([f"./{short_file}"])
                    else:
                        print(colored("Compilation failed. Errors:", "red"))
                        print(res.stderr.decode())

                    changes[file] = (mod_time, size)

        except KeyboardInterrupt:
            print("\nStopping Cppmon...")
            break
        except FileNotFoundError:
            print("\nFile not found. Restart Cppmon...")
            break


def welcome_screen(files):
    """
    This function displays the welcome screen and the list of files being monitored.
    """

    os.system("clear")
    print(colored("Welcome to Cppmon!\n", "yellow"))
    print("This program monitors the following up to ten files for changes and automatically compiles and runs your C++ code:\n")
    for file in files:
        print(colored(f" - {file}", "blue"))
    print("Now monitoring files...\n")


def check_files_exist(files):
    """Check if all files in a list exist and is not empty and is cpp file"""

    missing_files = []
    for file in files:
        if not os.path.isfile(file) or os.path.splitext(file)[1] != ".cpp":
            missing_files.append(file)
        elif os.path.getsize(file) == 0:
            missing_files.append(file)

    if missing_files:
        print(colored(
            "\nError: The following files do not exist or they are not cpp files:", "red"))
        for file in missing_files:
            print(colored(f"\t{file}", "red"))
        raise FileNotFoundError()

    return True


def main():
    parser = argparse.ArgumentParser(
        description='Monitor and compile C++ code on save.')
    parser.add_argument('files', type=str, nargs='+', help='files to monitor')
    args = parser.parse_args()

    if len(args.files) > 10:
        print(colored(
            f"Error: Cppmon can monitor up to 10 files at a time. You provided {len(args.files)} files.", "red"))
        sys.exit(1)

    welcome_screen(args.files)

    try:
        check_files_exist(args.files)
    except FileNotFoundError:
        sys.exit(1)

    stop_event = multiprocessing.Event()

    monitor_process = multiprocessing.Process(
        target=cppmon, args=(args.files, stop_event))
    monitor_process.start()

    while not stop_event.is_set():
        try:
            command = input(colored(
                "\nType command ('rs' to restart, 'c' to clear screen, 'q' to quit, 'h' for help, 'lf' to list files, 'af' to add file, 'rf' to remove file):", "yellow"))
            if command == 'rs':
                stop_event.set()
                monitor_process.join()
                stop_event.clear()
                os.system('clear')
                monitor_process = multiprocessing.Process(
                    target=cppmon, args=(args.files, stop_event))
                monitor_process.start()
            elif command == 'c':
                os.system('clear')
            elif command == 'q':
                stop_event.set()
                monitor_process.join()
                break
            elif command == 'h':
                print(colored("\nCppmon Instructions: ", "yellow"))
                print("Cppmon is a script that monitors your C++ source files for changes. When a change is detected, it automatically compiles and runs the modified code.")
                print("Commands available:\n"
                      "rs - restart script and clear screen\n"
                      "c - clear screen\n"
                      "q - quit\n"
                      "h - help\n"
                      "lf - list files being monitored\n"
                      "af - add a file to the monitoring list\n"
                      "rf - remove a file from the monitoring list")
            elif command == 'lf':
                print(colored("\nList of monitored files:", "yellow"))
                for file in args.files:
                    print(colored(f" - {file}", "blue"))
            elif command.startswith('af '):
                new_file = command.split(' ')[1]
                if new_file not in args.files and os.path.isfile(new_file) and os.path.splitext(new_file)[1] == ".cpp":
                    args.files.append(new_file)
                    print(
                        colored(f"Added {new_file} to monitoring list.", "green"))
                else:
                    print(colored(
                        "File does not exist, is not a cpp file, or is already being monitored.", "red"))
            elif command.startswith('rf '):
                remove_file = command.split(' ')[1]
                if remove_file in args.files:
                    args.files.remove(remove_file)
                    print(
                        colored(f"Removed {remove_file} from monitoring list.", "green"))
                else:
                    print(colored("File is not in the monitoring list.", "red"))
            else:
                print(colored("Invalid command, please try again.", "red"))
        except KeyboardInterrupt:
            break


if __name__ == "__main__":
    main()
